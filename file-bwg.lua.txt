-- ⚡ Saiyajin Flight - UI estilizada final (botones circulares y flechas)
-- R6 - LocalScript en StarterPlayerScripts
-- Controles: WASD + Space (subir) + LeftCtrl (bajar) + cruceta táctil
-- Mantiene toda la lógica de vuelo y boost previa, solo cambia la UI

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local guiParent = player:WaitForChild("PlayerGui")

local currentCleanup

local function safeDestroy(inst)
	if inst and inst.Parent then inst:Destroy() end
end

local function makeCircularButton(parent, size, pos, text, font, textScale)
	local btn = Instance.new("TextButton")
	btn.Size = size
	btn.Position = pos
	btn.AnchorPoint = Vector2.new(0.5, 0.5)
	btn.Text = text or ""
	btn.Font = font or Enum.Font.GothamBold
	btn.TextColor3 = Color3.new(1,1,1)
	btn.TextScaled = textScale or true
	btn.BackgroundColor3 = Color3.fromRGB(120,120,120)
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = parent

	local corner = Instance.new("UICorner", btn)
	corner.CornerRadius = UDim.new(1, 0) -- círculo perfecto

	local stroke = Instance.new("UIStroke", btn)
	stroke.Transparency = 0.6
	stroke.Thickness = 1
	stroke.Color = Color3.fromRGB(0,0,0)

	-- ligero "sombra" con UIGradient (suave)
	local grad = Instance.new("UIGradient", btn)
	grad.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255,255,255))
	}
	grad.Transparency = NumberSequence.new{ NumberSequenceKeypoint.new(0, 0.8), NumberSequenceKeypoint.new(1, 0.9) }

	return btn, corner, stroke, grad
end

local function createStylizedUI()
	-- limpiar si existe
	local existing = guiParent:FindFirstChild("SaiyanFlightUI")
	if existing then existing:Destroy() end

	local gui = Instance.new("ScreenGui", guiParent)
	gui.Name = "SaiyanFlightUI"
	gui.ResetOnSpawn = false

	-- Contenedor para top-right actions (fly + boost)
	local topFrame = Instance.new("Frame", gui)
	topFrame.Size = UDim2.new(0, 300, 0, 80)
	topFrame.Position = UDim2.new(1, -160, 0, 20)
	topFrame.AnchorPoint = Vector2.new(0.5, 0)
	topFrame.BackgroundTransparency = 1

	-- Fly button (derecha)
	local flyBtn, flyCorner = makeCircularButton(topFrame, UDim2.new(0, 64, 0, 64), UDim2.new(0.75, 0, 0.5, 0), "✈", Enum.Font.GothamBold, true)
	flyBtn.Name = "FlyButton"
	flyBtn.TextSize = 28

	-- Boost button (izquierda del Fly)
	local boostBtn, boostCorner = makeCircularButton(topFrame, UDim2.new(0, 64, 0, 64), UDim2.new(0.25, 0, 0.5, 0), "⇀", Enum.Font.GothamBold, true)
	boostBtn.Name = "BoostButton"
	boostBtn.TextSize = 28

	-- Ajustar el anclaje (ya usamos AnchorPoint en makeCircularButton)
	-- Añadir etiquetas pequeñas si hace falta (opcional)
	local flyLabel = Instance.new("TextLabel", topFrame)
	flyLabel.AnchorPoint = Vector2.new(0.5, 0)
	flyLabel.Position = UDim2.new(0.75, 0, 0.95, 0)
	flyLabel.BackgroundTransparency = 1
	flyLabel.Text = "Fly"
	flyLabel.TextColor3 = Color3.new(1,1,1)
	flyLabel.Font = Enum.Font.Gotham
	flyLabel.TextSize = 12

	local boostLabel = Instance.new("TextLabel", topFrame)
	boostLabel.AnchorPoint = Vector2.new(0.5, 0)
	boostLabel.Position = UDim2.new(0.25, 0, 0.95, 0)
	boostLabel.BackgroundTransparency = 1
	boostLabel.Text = "Boost"
	boostLabel.TextColor3 = Color3.new(1,1,1)
	boostLabel.Font = Enum.Font.Gotham
	boostLabel.TextSize = 12

	-- Cruceta circular bottom-left (flechas)
	local crossFrame = Instance.new("Frame", gui)
	crossFrame.Size = UDim2.new(0, 170, 0, 170)
	crossFrame.Position = UDim2.new(0, 20, 1, -190)
	crossFrame.BackgroundTransparency = 1

	-- posiciones relativas (centro X, Y offsets)
	local center = UDim2.new(0.5, 0, 0.5, 0)
	local btnSize = UDim2.new(0, 56, 0, 56)

	local btnUp, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.5, 0, 0.2, 0), "▲", Enum.Font.GothamBlack, true)
	local btnLeft, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.2, 0, 0.5, 0), "◄", Enum.Font.GothamBlack, true)
	local btnDown, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.5, 0, 0.8, 0), "▼", Enum.Font.GothamBlack, true)
	local btnRight, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.8, 0, 0.5, 0), "►", Enum.Font.GothamBlack, true)

	-- retorno de referencias
	return {
		gui = gui,
		flyBtn = flyBtn,
		boostBtn = boostBtn,
		btnW = btnUp,
		btnA = btnLeft,
		btnS = btnDown,
		btnD = btnRight,
		flyLabel = flyLabel,
		boostLabel = boostLabel,
	}
end

-- tween helpers para transiciones suaves de botones
local function tweenButtonState(btn, targetColor, duration)
	local tweenInfo = TweenInfo.new(duration or 0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local props = {BackgroundColor3 = targetColor}
	local t = TweenService:Create(btn, tweenInfo, props)
	t:Play()
	return t
end

local function tweenButtonPulse(btn, scaleUp)
	-- animación de pulsado: aumentar tamaño ligeramente y volver
	local base = btn.Size
	local up = UDim2.new(base.X.Scale, base.X.Offset * (scaleUp and 1.12 or 0.95), base.Y.Scale, base.Y.Offset * (scaleUp and 1.12 or 0.95))
	local tweenUp = TweenService:Create(btn, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = up})
	local tweenDown = TweenService:Create(btn, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = base})
	tweenUp:Play(); tweenUp.Completed:Wait()
	tweenDown:Play()
end

-- ---------------------------
-- Integración con el motor de vuelo anterior
-- ---------------------------

local function setupCharacter(character)
	-- limpiamos instancia anterior si existe
	if currentCleanup then currentCleanup() currentCleanup = nil end

	local hrp = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")

	-- ===== CONFIG Y ESTADO =====
	local defaultSpeed = 25
	local flySpeed = defaultSpeed
	local boostSpeed = 45
	local tiltFrontBack = 30
	local tiltSides = 25
	local tiltSmooth = 0.25
	local floatAmplitude = 1.5
	local floatSpeed = 6
	local accel = 12
	local normalFOV = workspace.CurrentCamera.FieldOfView or 80
	local boostFOV = 120

	local move = {W=false, A=false, S=false, D=false, Up=false, Down=false}
	local activeDir = nil
	local t = 0
	local boosting = false
	local flying = false

	-- limpiar BV/BG previos
	if hrp:FindFirstChild("SaiyanBV") then hrp.SaiyanBV:Destroy() end
	if hrp:FindFirstChild("SaiyanBG") then hrp.SaiyanBG:Destroy() end

	-- crear BV/BG
	local bv = Instance.new("BodyVelocity")
	bv.Name = "SaiyanBV"
	bv.MaxForce = Vector3.new(0,0,0)
	bv.P = 15000
	bv.Velocity = Vector3.new(0,0,0)
	bv.Parent = hrp

	local bg = Instance.new("BodyGyro")
	bg.Name = "SaiyanBG"
	bg.MaxTorque = Vector3.new(0,0,0)
	bg.P = 10000
	bg.D = 200
	bg.CFrame = hrp.CFrame
	bg.Parent = hrp

	-- Crear UI estilizada
	local ui = createStylizedUI()
	local flyBtn = ui.flyBtn
	local boostBtn = ui.boostBtn
	local btnW = ui.btnW
	local btnA = ui.btnA
	local btnS = ui.btnS
	local btnD = ui.btnD

	-- =========================
	-- Animaciones (IDs)
	-- =========================
	local animForwardTorso = Instance.new("Animation"); animForwardTorso.AnimationId = "rbxassetid://180436334"
	local animForwardLegs  = Instance.new("Animation"); animForwardLegs.AnimationId  = "rbxassetid://27744947"
	local animBackTorso    = Instance.new("Animation"); animBackTorso.AnimationId    = "rbxassetid://42071631"
	local animBackLegs     = Instance.new("Animation"); animBackLegs.AnimationId     = "rbxassetid://42070810"
	local animLeft         = Instance.new("Animation"); animLeft.AnimationId         = "rbxassetid://55789969"
	local animRight        = Instance.new("Animation"); animRight.AnimationId        = "rbxassetid://45069150"
	local animIdleLegs     = Instance.new("Animation"); animIdleLegs.AnimationId     = "rbxassetid://21632926"
	local animIdleTorso    = Instance.new("Animation"); animIdleTorso.AnimationId    = "rbxassetid://44448662"
	local animBoostHead    = Instance.new("Animation"); animBoostHead.AnimationId    = "rbxassetid://97169019"
	local animBoostBody    = Instance.new("Animation"); animBoostBody.AnimationId    = "rbxassetid://97172005"

	local forwardTorsoTrack = humanoid:LoadAnimation(animForwardTorso)
	local forwardLegsTrack  = humanoid:LoadAnimation(animForwardLegs)
	local backTorsoTrack    = humanoid:LoadAnimation(animBackTorso)
	local backLegsTrack     = humanoid:LoadAnimation(animBackLegs)
	local leftTrack         = humanoid:LoadAnimation(animLeft)
	local rightTrack        = humanoid:LoadAnimation(animRight)
	local idleLegsTrack     = humanoid:LoadAnimation(animIdleLegs)
	local idleTorsoTrack    = humanoid:LoadAnimation(animIdleTorso)
	local boostHeadTrack    = humanoid:LoadAnimation(animBoostHead)
	local boostBodyTrack    = humanoid:LoadAnimation(animBoostBody)

	for _, tr in pairs({forwardTorsoTrack, forwardLegsTrack, backTorsoTrack, backLegsTrack, leftTrack, rightTrack, idleLegsTrack, idleTorsoTrack, boostHeadTrack, boostBodyTrack}) do
		tr.Priority = Enum.AnimationPriority.Action
	end

	local function playFrozen(track)
		if not track.IsPlaying then track:Play() end
		track:AdjustSpeed(0)
	end
	local function stopTrack(track) if track.IsPlaying then track:Stop() end end
	local function stopAllAnim()
		for _, tr in pairs({forwardTorsoTrack, forwardLegsTrack, backTorsoTrack, backLegsTrack, leftTrack, rightTrack, idleLegsTrack, idleTorsoTrack, boostHeadTrack, boostBodyTrack}) do
			stopTrack(tr)
		end
	end

	-- conexiones
	local conns = {}

	table.insert(conns, UIS.InputBegan:Connect(function(input, processed)
		if processed then return end
		if input.KeyCode == Enum.KeyCode.W then move.W = true end
		if input.KeyCode == Enum.KeyCode.A then move.A = true end
		if input.KeyCode == Enum.KeyCode.S then move.S = true end
		if input.KeyCode == Enum.KeyCode.D then move.D = true end
		if input.KeyCode == Enum.KeyCode.Space then move.Up = true end
		if input.KeyCode == Enum.KeyCode.LeftControl then move.Down = true end
	end))

	table.insert(conns, UIS.InputEnded:Connect(function(input)
		if input.KeyCode == Enum.KeyCode.W then move.W = false end
		if input.KeyCode == Enum.KeyCode.A then move.A = false end
		if input.KeyCode == Enum.KeyCode.S then move.S = false end
		if input.KeyCode == Enum.KeyCode.D then move.D = false end
		if input.KeyCode == Enum.KeyCode.Space then move.Up = false end
		if input.KeyCode == Enum.KeyCode.LeftControl then move.Down = false end
	end))

	-- cruceta táctil events
	table.insert(conns, btnW.MouseButton1Down:Connect(function() move.W = true end))
	table.insert(conns, btnW.MouseButton1Up:Connect(function() move.W = false end))
	table.insert(conns, btnA.MouseButton1Down:Connect(function() move.A = true end))
	table.insert(conns, btnA.MouseButton1Up:Connect(function() move.A = false end))
	table.insert(conns, btnS.MouseButton1Down:Connect(function() move.S = true end))
	table.insert(conns, btnS.MouseButton1Up:Connect(function() move.S = false end))
	table.insert(conns, btnD.MouseButton1Down:Connect(function() move.D = true end))
	table.insert(conns, btnD.MouseButton1Up:Connect(function() move.D = false end))

	-- Tween helper FOV
	local function tweenFOV(target)
		local cam = workspace.CurrentCamera
		local tween = TweenService:Create(cam, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {FieldOfView = target})
		tween:Play()
	end

	-- BOOST control (prioridad y reemplazo de W anim)
	local function startBoost()
		if not flying then return end
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)
		if math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) <= 0 then return end

		if boosting then return end
		boosting = true
		flySpeed = boostSpeed

		-- parar animacion W para evitar solapamientos
		if forwardTorsoTrack.IsPlaying then forwardTorsoTrack:Stop() end
		if forwardLegsTrack.IsPlaying then forwardLegsTrack:Stop() end

		-- reproducir anim de boost (en speed normal)
		if not boostHeadTrack.IsPlaying then boostHeadTrack:Play() end
		if not boostBodyTrack.IsPlaying then boostBodyTrack:Play() end
		boostHeadTrack:AdjustSpeed(1)
		boostBodyTrack:AdjustSpeed(1)

		-- FOV y UI
		tweenFOV(boostFOV)
		TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0,150,255)}):Play()
		boostBtn.Text = "⇀"
		tweenButtonPulse(boostBtn, true)

		-- fuerza de BV mayor para boost sostenido
		bv.MaxForce = Vector3.new(8000,8000,8000)
		activeDir = "Boost"
	end

	local function stopBoost()
		if not boosting then return end
		boosting = false
		flySpeed = defaultSpeed

		-- detener animaciones de boost
		if boostHeadTrack.IsPlaying then boostHeadTrack:Stop() end
		if boostBodyTrack.IsPlaying then boostBodyTrack:Stop() end

		-- volver FOV y UI
		tweenFOV(normalFOV)
		TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(255,50,50)}):Play()
		boostBtn.Text = "⇀"
		tweenButtonPulse(boostBtn, false)

		bv.MaxForce = Vector3.new(4000,4000,4000)

		-- reactivar W anim si W está presionado
		if move.W then
			activeDir = "W"
			playFrozen(forwardTorsoTrack)
			playFrozen(forwardLegsTrack)
		else
			activeDir = nil
		end
	end

	-- Boost button click
	table.insert(conns, boostBtn.MouseButton1Click:Connect(function()
		if not flying then return end
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)
		if math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) <= 0 then return end

		if boosting then stopBoost() else startBoost() end
	end))

	-- Fly button click (toggle)
	table.insert(conns, flyBtn.MouseButton1Click:Connect(function()
		flying = not flying
		if flying then
			flyBtn.Text = "✈"
			TweenService:Create(flyBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0,255,100)}):Play()
			humanoid.PlatformStand = true
			bv.MaxForce = Vector3.new(4000,4000,4000)
			bg.MaxTorque = Vector3.new(4000,4000,4000)
			tweenButtonPulse(flyBtn, true)
		else
			flyBtn.Text = "✈"
			TweenService:Create(flyBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(255,50,50)}):Play()
			humanoid.PlatformStand = false
			bv.MaxForce = Vector3.new(0,0,0)
			bg.MaxTorque = Vector3.new(0,0,0)
			-- apagar anims y boost
			stopAllAnim()
			if boosting then stopBoost() end
			activeDir = nil
		end
	end))

	-- RENDER: movimiento, animaciones y lógica boost/idle
	local renderConn
	renderConn = RunService.RenderStepped:Connect(function(dt)
		if not flying then return end

		local cam = workspace.CurrentCamera
		local cf = cam.CFrame

		-- entradas numéricas
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)

		-- construir desiredDir según cámara (incluye vertical componente)
		local desiredDir = Vector3.zero
		desiredDir += cf.LookVector * forwardInput
		desiredDir += cf.RightVector * rightInput
		desiredDir += Vector3.new(0,1,0) * upInput

		-- Si boosting -> prioridad Boost (ya manejado por startBoost/stopBoost)
		local newActive = nil
		if boosting then
			newActive = "Boost"
		else
			if forwardInput ~= 0 then newActive = "W"
			elseif move.S then newActive = "S"
			elseif move.A then newActive = "A"
			elseif move.D then newActive = "D"
			else newActive = "Idle" end
		end

		-- actualizar animaciones si cambió la dirección activa (Boost detiene W)
		if newActive ~= activeDir then
			stopAllAnim()
			activeDir = newActive

			if activeDir == "W" then
				playFrozen(forwardTorsoTrack); playFrozen(forwardLegsTrack)
			elseif activeDir == "S" then
				playFrozen(backTorsoTrack); playFrozen(backLegsTrack)
			elseif activeDir == "A" then
				playFrozen(leftTrack)
			elseif activeDir == "D" then
				playFrozen(rightTrack)
			elseif activeDir == "Idle" then
				playFrozen(idleLegsTrack); playFrozen(idleTorsoTrack)
			elseif activeDir == "Boost" then
				-- asegurar boost playing (si no fue iniciado desde botón)
				if not boostHeadTrack.IsPlaying then boostHeadTrack:Play() end
				if not boostBodyTrack.IsPlaying then boostBodyTrack:Play() end
				boostHeadTrack:AdjustSpeed(1)
				boostBodyTrack:AdjustSpeed(1)
			end
		end

		-- habilitar/deshabilitar UI del boost según movimiento
		local movingNow = math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) > 0
		if movingNow and flying then
			if not boosting then
				TweenService:Create(boostBtn, TweenInfo.new(0.12), {BackgroundColor3 = Color3.fromRGB(0,150,255)}):Play()
				-- mostrar como usable (si no boosting, color azulado tenue)
				TweenService:Create(boostBtn, TweenInfo.new(0.2), {BackgroundTransparency = 0}):Play()
			else
				TweenService:Create(boostBtn, TweenInfo.new(0.12), {BackgroundColor3 = Color3.fromRGB(255,170,0)}):Play()
			end
			boostBtn.Active = true
		else
			if not boosting then
				TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(120,120,120)}):Play()
				TweenService:Create(boostBtn, TweenInfo.new(0.2), {BackgroundTransparency = 0.35}):Play()
			end
			boostBtn.Active = false
			-- si estaba boosteando y dejo de moverse -> stopBoost
			if boosting and not movingNow then stopBoost() end
		end

		-- movimiento físico
		if desiredDir.Magnitude > 0.001 then
			local desiredVel = desiredDir.Unit * flySpeed
			local lerpFactor = math.clamp(accel * dt, 0, 1)
			bv.Velocity = bv.Velocity:Lerp(desiredVel, lerpFactor)
		else
			t = t + dt * floatSpeed
			local floatY = math.sin(t * 6) * floatAmplitude
			local desiredVel = Vector3.new(0, floatY, 0)
			local lerpFactor = math.clamp(accel * dt, 0, 1)
			bv.Velocity = bv.Velocity:Lerp(desiredVel, lerpFactor)
		end

		-- inclinacion: forzar 90° en boost, sino normales
		local tiltX, tiltZ = 0, 0
		if boosting then
			tiltX = -90
			tiltZ = 0
		else
			if move.W then tiltX = -tiltFrontBack end
			if move.S then tiltX = tiltFrontBack end
			if move.A then tiltZ = tiltSides end
			if move.D then tiltZ = -tiltSides end
		end

		local targetCF = CFrame.new(hrp.Position, hrp.Position + cf.LookVector) * CFrame.Angles(math.rad(tiltX), 0, math.rad(tiltZ))
		local lerpAmount = boosting and 0.8 or tiltSmooth
		bg.CFrame = bg.CFrame:Lerp(targetCF, lerpAmount)
	end)

	table.insert(conns, renderConn)

	-- cleanup
	currentCleanup = function()
		for _, c in ipairs(conns) do if c and c.Disconnect then c:Disconnect() end end
		if renderConn and renderConn.Disconnect then renderConn:Disconnect() end
		safeDestroy(bv); safeDestroy(bg)
		local exist = guiParent:FindFirstChild("SaiyanFlightUI")
		if exist then exist:Destroy() end
		stopAllAnim()
		-- reset FOV por si quedó en boost
		pcall(function() TweenService:Create(workspace.CurrentCamera, TweenInfo.new(0.15), {FieldOfView = normalFOV}):Play() end)
	end

	return {
		cleanup = currentCleanup
	}
end

-- init + respawn handling
local function init()
	local char = player.Character or player.CharacterAdded:Wait()
	setupCharacter(char)
	player.CharacterAdded:Connect(function(c)
		if currentCleanup then currentCleanup() currentCleanup = nil end
		task.wait(0.12)
		setupCharacter(c)
	end)
end

init()
