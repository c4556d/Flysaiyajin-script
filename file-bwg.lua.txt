-- ‚ö° Saiyajin Flight - UI estilizada final + Hyper Boost (integrado)
-- R6 - LocalScript en StarterPlayerScripts
-- Controles: WASD + Space (subir) + LeftCtrl (bajar) + cruceta t√°ctil

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local guiParent = player:WaitForChild("PlayerGui")

local currentCleanup

local function safeDestroy(inst)
	if inst and inst.Parent then inst:Destroy() end
end

local function makeCircularButton(parent, size, pos, text, font, textScale)
	local btn = Instance.new("TextButton")
	btn.Size = size
	btn.Position = pos
	btn.AnchorPoint = Vector2.new(0.5, 0.5)
	btn.Text = text or ""
	btn.Font = font or Enum.Font.GothamBold
	btn.TextColor3 = Color3.new(1,1,1)
	btn.TextScaled = textScale or true
	btn.BackgroundColor3 = Color3.fromRGB(120,120,120)
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = false
	btn.Parent = parent

	local corner = Instance.new("UICorner", btn)
	corner.CornerRadius = UDim.new(1, 0) -- c√≠rculo perfecto

	local stroke = Instance.new("UIStroke", btn)
	stroke.Transparency = 0.6
	stroke.Thickness = 1
	stroke.Color = Color3.fromRGB(0,0,0)

	-- ligero "sombra" con UIGradient (suave)
	local grad = Instance.new("UIGradient", btn)
	grad.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255,255,255))
	}
	grad.Transparency = NumberSequence.new{ NumberSequenceKeypoint.new(0, 0.8), NumberSequenceKeypoint.new(1, 0.9) }

	return btn, corner, stroke, grad
end

local function createStylizedUI()
	-- limpiar si existe
	local existing = guiParent:FindFirstChild("SaiyanFlightUI")
	if existing then existing:Destroy() end

	local gui = Instance.new("ScreenGui", guiParent)
	gui.Name = "SaiyanFlightUI"
	gui.ResetOnSpawn = false

	-- Contenedor para top-right actions (hyper + boost + fly)
	local topFrame = Instance.new("Frame", gui)
	topFrame.Size = UDim2.new(0, 360, 0, 80)
	topFrame.Position = UDim2.new(1, -200, 0, 20)
	topFrame.AnchorPoint = Vector2.new(0.5, 0)
	topFrame.BackgroundTransparency = 1

	-- Hyper button (izquierda del Boost) - circular
	local hyperBtn, _ = makeCircularButton(topFrame, UDim2.new(0, 64, 0, 64), UDim2.new(0.08, 0, 0.5, 0), "ü¶∏", Enum.Font.GothamBold, true)
	hyperBtn.Name = "HyperButton"
	hyperBtn.TextSize = 26

	-- Boost button (centro-izq)
	local boostBtn, _ = makeCircularButton(topFrame, UDim2.new(0, 64, 0, 64), UDim2.new(0.25, 0, 0.5, 0), "‚áÄ", Enum.Font.GothamBold, true)
	boostBtn.Name = "BoostButton"
	boostBtn.TextSize = 28

	-- Fly button (derecha)
	local flyBtn, _ = makeCircularButton(topFrame, UDim2.new(0, 64, 0, 64), UDim2.new(0.75, 0, 0.5, 0), "‚úà", Enum.Font.GothamBold, true)
	flyBtn.Name = "FlyButton"
	flyBtn.TextSize = 28

	-- etiquetas
	local flyLabel = Instance.new("TextLabel", topFrame)
	flyLabel.AnchorPoint = Vector2.new(0.5, 0)
	flyLabel.Position = UDim2.new(0.75, 0, 0.95, 0)
	flyLabel.BackgroundTransparency = 1
	flyLabel.Text = "Fly"
	flyLabel.TextColor3 = Color3.new(1,1,1)
	flyLabel.Font = Enum.Font.Gotham
	flyLabel.TextSize = 12

	local boostLabel = Instance.new("TextLabel", topFrame)
	boostLabel.AnchorPoint = Vector2.new(0.5, 0)
	boostLabel.Position = UDim2.new(0.25, 0, 0.95, 0)
	boostLabel.BackgroundTransparency = 1
	boostLabel.Text = "Boost"
	boostLabel.TextColor3 = Color3.new(1,1,1)
	boostLabel.Font = Enum.Font.Gotham
	boostLabel.TextSize = 12

	local hyperLabel = Instance.new("TextLabel", topFrame)
	hyperLabel.AnchorPoint = Vector2.new(0.5, 0)
	hyperLabel.Position = UDim2.new(0.08, 0, 0.95, 0)
	hyperLabel.BackgroundTransparency = 1
	hyperLabel.Text = "Hyper"
	hyperLabel.TextColor3 = Color3.new(1,1,1)
	hyperLabel.Font = Enum.Font.Gotham
	hyperLabel.TextSize = 12

	-- Cruceta circular bottom-left (flechas)
	local crossFrame = Instance.new("Frame", gui)
	crossFrame.Size = UDim2.new(0, 170, 0, 170)
	crossFrame.Position = UDim2.new(0, 20, 1, -190)
	crossFrame.BackgroundTransparency = 1

	local btnSize = UDim2.new(0, 56, 0, 56)
	local btnUp, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.5, 0, 0.2, 0), "‚ñ≤", Enum.Font.GothamBlack, true)
	local btnLeft, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.2, 0, 0.5, 0), "‚óÑ", Enum.Font.GothamBlack, true)
	local btnDown, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.5, 0, 0.8, 0), "‚ñº", Enum.Font.GothamBlack, true)
	local btnRight, _ = makeCircularButton(crossFrame, btnSize, UDim2.new(0.8, 0, 0.5, 0), "‚ñ∫", Enum.Font.GothamBlack, true)

	-- retorno de referencias
	return {
		gui = gui,
		flyBtn = flyBtn,
		boostBtn = boostBtn,
		hyperBtn = hyperBtn,
		btnW = btnUp,
		btnA = btnLeft,
		btnS = btnDown,
		btnD = btnRight,
		flyLabel = flyLabel,
		boostLabel = boostLabel,
		hyperLabel = hyperLabel,
	}
end

-- tween helpers para transiciones suaves de botones
local function tweenButtonState(btn, targetColor, duration)
	local tweenInfo = TweenInfo.new(duration or 0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local props = {BackgroundColor3 = targetColor}
	local t = TweenService:Create(btn, tweenInfo, props)
	t:Play()
	return t
end

local function tweenButtonPulse(btn, scaleUp)
	-- animaci√≥n de pulsado: aumentar tama√±o ligeramente y volver
	local base = btn.Size
	local up = UDim2.new(base.X.Scale, base.X.Offset * (scaleUp and 1.12 or 0.95), base.Y.Scale, base.Y.Offset * (scaleUp and 1.12 or 0.95))
	local tweenUp = TweenService:Create(btn, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = up})
	local tweenDown = TweenService:Create(btn, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = base})
	tweenUp:Play(); tweenUp.Completed:Wait()
	tweenDown:Play()
end

-- ---------------------------
-- Integraci√≥n con el motor de vuelo anterior
-- ---------------------------

local function setupCharacter(character)
	-- limpiamos instancia anterior si existe
	if currentCleanup then currentCleanup() currentCleanup = nil end

	local hrp = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")

	-- ===== CONFIG Y ESTADO =====
	local defaultSpeed = 25
	local flySpeed = defaultSpeed
	local boostSpeed = 45
	local hyperSpeed = 178
	local tiltFrontBack = 30
	local tiltSides = 25
	local tiltSmooth = 0.25
	local floatAmplitude = 1.5
	local floatSpeed = 6
	local accel = 12
	local normalFOV = workspace.CurrentCamera.FieldOfView or 80
	local boostFOV = 120
	local hyperFOV = 130

	local move = {W=false, A=false, S=false, D=false, Up=false, Down=false}
	local activeDir = nil
	local t = 0
	local boosting = false
	local flying = false
	local hyperActive = false

	-- BV/BG (se crean y destruyen cuando se activa/desactiva Fly para evitar "restos")
	local bv, bg

	local function createBVBG()
		if bv and bv.Parent then return end
		if bg and bg.Parent then return end
		-- crear BV/BG
		bv = Instance.new("BodyVelocity")
		bv.Name = "SaiyanBV"
		bv.MaxForce = Vector3.new(0,0,0)
		bv.P = 15000
		bv.Velocity = Vector3.new(0,0,0)
		bv.Parent = hrp

		bg = Instance.new("BodyGyro")
		bg.Name = "SaiyanBG"
		bg.MaxTorque = Vector3.new(0,0,0)
		bg.P = 10000
		bg.D = 200
		bg.CFrame = hrp.CFrame
		bg.Parent = hrp
	end

	local function destroyBVBG()
		if bv then safeDestroy(bv); bv = nil end
		if bg then safeDestroy(bg); bg = nil end
	end

	-- Crear UI estilizada
	local ui = createStylizedUI()
	local flyBtn = ui.flyBtn
	local boostBtn = ui.boostBtn
	local hyperBtn = ui.hyperBtn
	local btnW = ui.btnW
	local btnA = ui.btnA
	local btnS = ui.btnS
	local btnD = ui.btnD

	-- =========================
	-- Animaciones (IDs)
	-- =========================
	local animForwardTorso = Instance.new("Animation"); animForwardTorso.AnimationId = "rbxassetid://180436334"
	local animForwardLegs  = Instance.new("Animation"); animForwardLegs.AnimationId  = "rbxassetid://27744947"
	local animBackTorso    = Instance.new("Animation"); animBackTorso.AnimationId    = "rbxassetid://42071631"
	local animBackLegs     = Instance.new("Animation"); animBackLegs.AnimationId     = "rbxassetid://42070810"
	local animLeft         = Instance.new("Animation"); animLeft.AnimationId         = "rbxassetid://27751170" -- <--- cambiado a 27751170
	local animRight        = Instance.new("Animation"); animRight.AnimationId        = "rbxassetid://45069150"
	local animIdleLegs     = Instance.new("Animation"); animIdleLegs.AnimationId     = "rbxassetid://21632926"
	local animIdleTorso    = Instance.new("Animation"); animIdleTorso.AnimationId    = "rbxassetid://44448662"
	local animBoostHead    = Instance.new("Animation"); animBoostHead.AnimationId    = "rbxassetid://97169019"
	local animBoostBody    = Instance.new("Animation"); animBoostBody.AnimationId    = "rbxassetid://97172005"
	local animHyper        = Instance.new("Animation"); animHyper.AnimationId        = "rbxassetid://90872539" -- hyper

	-- cargar tracks (no se reproducen hasta que los necesitemos)
	local forwardTorsoTrack = humanoid:LoadAnimation(animForwardTorso)
	local forwardLegsTrack  = humanoid:LoadAnimation(animForwardLegs)
	local backTorsoTrack    = humanoid:LoadAnimation(animBackTorso)
	local backLegsTrack     = humanoid:LoadAnimation(animBackLegs)
	local leftTrack         = humanoid:LoadAnimation(animLeft)
	local rightTrack        = humanoid:LoadAnimation(animRight)
	local idleLegsTrack     = humanoid:LoadAnimation(animIdleLegs)
	local idleTorsoTrack    = humanoid:LoadAnimation(animIdleTorso)
	local boostHeadTrack    = humanoid:LoadAnimation(animBoostHead)
	local boostBodyTrack    = humanoid:LoadAnimation(animBoostBody)
	local hyperTrack        = humanoid:LoadAnimation(animHyper)

	for _, tr in pairs({forwardTorsoTrack, forwardLegsTrack, backTorsoTrack, backLegsTrack, leftTrack, rightTrack, idleLegsTrack, idleTorsoTrack, boostHeadTrack, boostBodyTrack, hyperTrack}) do
		tr.Priority = Enum.AnimationPriority.Action
	end

	-- helper: reproducir congelado (play + speed 0)
	local function playFrozen(track)
		if not track.IsPlaying then track:Play() end
		track:AdjustSpeed(0)
	end
	local function stopTrack(track) if track.IsPlaying then track:Stop() end end
	local function stopAllAnim()
		for _, tr in pairs({forwardTorsoTrack, forwardLegsTrack, backTorsoTrack, backLegsTrack, leftTrack, rightTrack, idleLegsTrack, idleTorsoTrack, boostHeadTrack, boostBodyTrack, hyperTrack}) do
			stopTrack(tr)
		end
	end

	-- conexiones
	local conns = {}

	table.insert(conns, UIS.InputBegan:Connect(function(input, processed)
		if processed then return end
		if input.KeyCode == Enum.KeyCode.W then move.W = true end
		if input.KeyCode == Enum.KeyCode.A then move.A = true end
		if input.KeyCode == Enum.KeyCode.S then move.S = true end
		if input.KeyCode == Enum.KeyCode.D then move.D = true end
		if input.KeyCode == Enum.KeyCode.Space then move.Up = true end
		if input.KeyCode == Enum.KeyCode.LeftControl then move.Down = true end
	end))

	table.insert(conns, UIS.InputEnded:Connect(function(input)
		if input.KeyCode == Enum.KeyCode.W then move.W = false end
		if input.KeyCode == Enum.KeyCode.A then move.A = false end
		if input.KeyCode == Enum.KeyCode.S then move.S = false end
		if input.KeyCode == Enum.KeyCode.D then move.D = false end
		if input.KeyCode == Enum.KeyCode.Space then move.Up = false end
		if input.KeyCode == Enum.KeyCode.LeftControl then move.Down = false end
	end))

	-- cruceta t√°ctil events
	table.insert(conns, btnW.MouseButton1Down:Connect(function() move.W = true end))
	table.insert(conns, btnW.MouseButton1Up:Connect(function() move.W = false end))
	table.insert(conns, btnA.MouseButton1Down:Connect(function() move.A = true end))
	table.insert(conns, btnA.MouseButton1Up:Connect(function() move.A = false end))
	table.insert(conns, btnS.MouseButton1Down:Connect(function() move.S = true end))
	table.insert(conns, btnS.MouseButton1Up:Connect(function() move.S = false end))
	table.insert(conns, btnD.MouseButton1Down:Connect(function() move.D = true end))
	table.insert(conns, btnD.MouseButton1Up:Connect(function() move.D = false end))

	-- Tween helper FOV
	local function tweenFOV(target)
		local cam = workspace.CurrentCamera
		local tween = TweenService:Create(cam, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {FieldOfView = target})
		tween:Play()
	end

	-- BOOST control (prioridad y reemplazo de W anim)
	local function startBoost()
		if not flying then return end
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)
		if math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) <= 0 then return end

		if boosting then return end
		boosting = true
		flySpeed = boostSpeed

		-- parar animacion W para evitar solapamientos
		if forwardTorsoTrack.IsPlaying then forwardTorsoTrack:Stop() end
		if forwardLegsTrack.IsPlaying then forwardLegsTrack:Stop() end

		-- reproducir anim de boost (en speed normal)
		if not boostHeadTrack.IsPlaying then boostHeadTrack:Play() end
		if not boostBodyTrack.IsPlaying then boostBodyTrack:Play() end
		boostHeadTrack:AdjustSpeed(1)
		boostBodyTrack:AdjustSpeed(1)

		-- FOV y UI
		tweenFOV(boostFOV)
		TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0,150,255)}):Play()
		boostBtn.Text = "‚áÄ"
		tweenButtonPulse(boostBtn, true)

		-- fuerza de BV mayor para boost sostenido
		if bv then bv.MaxForce = Vector3.new(8000,8000,8000) end
		activeDir = "Boost"
	end

	local function stopBoost()
		if not boosting then return end
		boosting = false
		flySpeed = defaultSpeed

		-- detener animaciones de boost
		if boostHeadTrack.IsPlaying then boostHeadTrack:Stop() end
		if boostBodyTrack.IsPlaying then boostBodyTrack:Stop() end

		-- volver FOV y UI
		tweenFOV(normalFOV)
		TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(255,50,50)}):Play()
		boostBtn.Text = "‚áÄ"
		tweenButtonPulse(boostBtn, false)

		if bv then bv.MaxForce = Vector3.new(4000,4000,4000) end

		-- reactivar W anim si W est√° presionado
		if move.W then
			activeDir = "W"
			playFrozen(forwardTorsoTrack)
			playFrozen(forwardLegsTrack)
		else
			activeDir = nil
		end
	end

	-- Boost button click
	table.insert(conns, boostBtn.MouseButton1Click:Connect(function()
		if not flying then return end
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)
		if math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) <= 0 then return end

		if boosting then stopBoost() else startBoost() end
	end))

	-- Hyper Boost functions (usando anim: 90872539)
	local function startHyper()
		if not flying then return end
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)
		if math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) <= 0 then return end
		if hyperActive then return end

		-- stop boost if active
		if boosting then stopBoost() end

		hyperActive = true

		-- UI
		hyperBtn.Text = "ü¶∏"
		TweenService:Create(hyperBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0,255,100)}):Play()
		tweenButtonPulse(hyperBtn, true)

		-- detener W anim para evitar solapamiento
		if forwardTorsoTrack.IsPlaying then forwardTorsoTrack:Stop() end
		if forwardLegsTrack.IsPlaying then forwardLegsTrack:Stop() end

		-- reproducir y congelar anim Hyper (la pose queda)
		if not hyperTrack.IsPlaying then hyperTrack:Play() end
		task.wait(0.02)
		hyperTrack:AdjustSpeed(0)

		-- ajustar velocidad, FOV y BV
		flySpeed = hyperSpeed
		tweenFOV(hyperFOV)
		if bv then bv.MaxForce = Vector3.new(1e5,1e5,1e5) end

		activeDir = "Hyper"
	end

	local function stopHyper()
		if not hyperActive then return end
		hyperActive = false

		-- UI revert
		TweenService:Create(hyperBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(255,50,50)}):Play()
		tweenButtonPulse(hyperBtn, false)
		-- detener anim
		if hyperTrack.IsPlaying then hyperTrack:Stop() end

		-- restaurar velocidad y FOV
		flySpeed = defaultSpeed
		tweenFOV(normalFOV)

		-- reset BV force
		if bv then bv.MaxForce = Vector3.new(4000,4000,4000) end

		-- reactivar W anim si W est√° presionado
		if move.W then
			activeDir = "W"
			playFrozen(forwardTorsoTrack)
			playFrozen(forwardLegsTrack)
		else
			activeDir = nil
		end
	end

	-- Hyper button click
	table.insert(conns, hyperBtn.MouseButton1Click:Connect(function()
		if not flying then return end
		local movingNow = math.abs((move.W and 1 or 0) - (move.S and 1 or 0)) + math.abs((move.D and 1 or 0) - (move.A and 1 or 0)) + math.abs((move.Up and 1 or 0) - (move.Down and 1 or 0)) > 0
		if not movingNow then return end

		if hyperActive then
			stopHyper()
		else
			startHyper()
		end
	end))

	-- Fly button click (toggle) -> ahora crea BV/BG cuando se activa, y los destruye por completo cuando se desactiva
	table.insert(conns, flyBtn.MouseButton1Click:Connect(function()
		flying = not flying
		if flying then
			-- activar vuelo: (crea BV/BG si no existen)
			createBVBG()
			TweenService:Create(flyBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0,255,100)}):Play()
			humanoid.PlatformStand = true
			if bv then bv.MaxForce = Vector3.new(4000,4000,4000) end
			if bg then bg.MaxTorque = Vector3.new(4000,4000,4000) end
			tweenButtonPulse(flyBtn, true)
		else
			-- DESACTIVACI√ìN COMPLETA: limpiar TODO para que no quede nada activo
			flying = false

			-- parar Boost / Hyper si estuvieran activos
			if boosting then stopBoost() end
			if hyperActive then stopHyper() end

			-- stop anims
			stopAllAnim()

			-- restaurar PlatformStand y propiedades f√≠sicas
			humanoid.PlatformStand = false
			if bv then bv.MaxForce = Vector3.new(0,0,0) end
			if bg then bg.MaxTorque = Vector3.new(0,0,0) end

			-- destruir BV/BG completamente para evitar residuos
			destroyBVBG()

			-- restablecer FOV
			pcall(function() TweenService:Create(workspace.CurrentCamera, TweenInfo.new(0.15), {FieldOfView = normalFOV}):Play() end)

			-- UI
			TweenService:Create(flyBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(255,50,50)}):Play()
			flyBtn.Text = "‚úà"
			tweenButtonPulse(flyBtn, false)

			-- reiniciar estado activo
			activeDir = nil
		end
	end))

	-- RENDER: movimiento, animaciones y l√≥gica boost/idle/hyper
	local renderConn
	renderConn = RunService.RenderStepped:Connect(function(dt)
		-- si no hay vuelo activo, salir r√°pido
		if not flying then return end

		-- asegurar BV/BG existen (por si re-entrant)
		createBVBG()

		local cam = workspace.CurrentCamera
		local cf = cam.CFrame

		-- entradas num√©ricas
		local forwardInput = (move.W and 1 or 0) - (move.S and 1 or 0)
		local rightInput   = (move.D and 1 or 0) - (move.A and 1 or 0)
		local upInput      = (move.Up and 1 or 0) - (move.Down and 1 or 0)

		-- construir desiredDir seg√∫n c√°mara (incluye vertical componente)
		local desiredDir = Vector3.zero
		desiredDir += cf.LookVector * forwardInput
		desiredDir += cf.RightVector * rightInput
		desiredDir += Vector3.new(0,1,0) * upInput

		-- Si boosting/hyper -> prioridad
		local newActive = nil
		if hyperActive then
			newActive = "Hyper"
		elseif boosting then
			newActive = "Boost"
		else
			if forwardInput ~= 0 then newActive = "W"
			elseif move.S then newActive = "S"
			elseif move.A then newActive = "A"
			elseif move.D then newActive = "D"
			else newActive = "Idle" end
		end

		-- actualizar animaciones si cambi√≥ la direcci√≥n activa
		-- nota: si hyperActive est√° en true, priorizamos su animaci√≥n y no reproducimos W
		if not hyperActive and newActive ~= activeDir then
			-- stop previo
			stopAllAnim()
			activeDir = newActive

			if activeDir == "W" then
				playFrozen(forwardTorsoTrack); playFrozen(forwardLegsTrack)
			elseif activeDir == "S" then
				playFrozen(backTorsoTrack); playFrozen(backLegsTrack)
			elseif activeDir == "A" then
				-- A usa la anim nueva (27751170) y se congela
				playFrozen(leftTrack)
			elseif activeDir == "D" then
				playFrozen(rightTrack)
			elseif activeDir == "Idle" then
				playFrozen(idleLegsTrack); playFrozen(idleTorsoTrack)
			elseif activeDir == "Boost" then
				-- asegurar boost playing
				if not boostHeadTrack.IsPlaying then boostHeadTrack:Play() end
				if not boostBodyTrack.IsPlaying then boostBodyTrack:Play() end
				boostHeadTrack:AdjustSpeed(1)
				boostBodyTrack:AdjustSpeed(1)
			end
		end

		-- habilitar/deshabilitar UI del boost seg√∫n movimiento
		local movingNow = math.abs(forwardInput) + math.abs(rightInput) + math.abs(upInput) > 0
		if movingNow and flying then
			if not boosting and not hyperActive then
				TweenService:Create(boostBtn, TweenInfo.new(0.12), {BackgroundColor3 = Color3.fromRGB(0,150,255)}):Play()
				TweenService:Create(boostBtn, TweenInfo.new(0.2), {BackgroundTransparency = 0}):Play()
			elseif boosting then
				TweenService:Create(boostBtn, TweenInfo.new(0.12), {BackgroundColor3 = Color3.fromRGB(255,170,0)}):Play()
			end
			boostBtn.Active = true
		else
			if not boosting then
				TweenService:Create(boostBtn, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(120,120,120)}):Play()
				TweenService:Create(boostBtn, TweenInfo.new(0.2), {BackgroundTransparency = 0.35}):Play()
			end
			boostBtn.Active = false
			-- si estaba boosteando y dejo de moverse -> stopBoost
			if boosting and not movingNow then stopBoost() end
		end

		-- auto-stop hyper si dej√°s de moverte
		if hyperActive and not movingNow then
			stopHyper()
		end

		-- movimiento f√≠sico
		if desiredDir.Magnitude > 0.001 then
			local desiredVel = desiredDir.Unit * flySpeed
			local lerpFactor = math.clamp(accel * dt, 0, 1)
			if bv then bv.Velocity = bv.Velocity:Lerp(desiredVel, lerpFactor) end
		else
			t = t + dt * floatSpeed
			local floatY = math.sin(t * 6) * floatAmplitude
			local desiredVel = Vector3.new(0, floatY, 0)
			local lerpFactor = math.clamp(accel * dt, 0, 1)
			if bv then bv.Velocity = bv.Velocity:Lerp(desiredVel, lerpFactor) end
		end

		-- inclinacion: priorizar hyper (90¬∞ suave), luego boost (90¬∞), sino normales
		local tiltX, tiltZ = 0, 0
		if hyperActive then
			tiltX = -90
			tiltZ = 0
		elseif boosting then
			tiltX = -90
			tiltZ = 0
		else
			if move.W then tiltX = -tiltFrontBack end
			if move.S then tiltX = tiltFrontBack end
			if move.A then tiltZ = tiltSides end
			if move.D then tiltZ = -tiltSides end
		end

		-- aplicar giro (suave)
		if bg then
			local targetCF = CFrame.new(hrp.Position, hrp.Position + cf.LookVector) * CFrame.Angles(math.rad(tiltX), 0, math.rad(tiltZ))
			local lerpAmount = hyperActive and 0.9 or (boosting and 0.8 or tiltSmooth)
			bg.CFrame = bg.CFrame:Lerp(targetCF, lerpAmount)
		end
	end)

	table.insert(conns, renderConn)

	-- cleanup
	currentCleanup = function()
		for _, c in ipairs(conns) do if c and c.Disconnect then c:Disconnect() end end
		if renderConn and renderConn.Disconnect then renderConn:Disconnect() end
		-- destruir BV/BG por completo
		destroyBVBG()
		-- quitar UI
		local exist = guiParent:FindFirstChild("SaiyanFlightUI")
		if exist then exist:Destroy() end
		-- detener anims
		stopAllAnim()
		-- reset FOV por si qued√≥ en boost/hyper
		pcall(function() TweenService:Create(workspace.CurrentCamera, TweenInfo.new(0.15), {FieldOfView = normalFOV}):Play() end)
	end

	return {
		cleanup = currentCleanup
	}
end

-- init + respawn handling
local function init()
	local char = player.Character or player.CharacterAdded:Wait()
	setupCharacter(char)
	player.CharacterAdded:Connect(function(c)
		if currentCleanup then currentCleanup() currentCleanup = nil end
		task.wait(0.12)
		setupCharacter(c)
	end)
end

init()
